<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>axlscld</title>
  <link rel="icon" href="/images/axl-logo.png">
  <link rel="stylesheet" href="https://axlescalada.github.io/app.css"/>
</head>

<body>
  <div class="flex-body">
    <div class="header">
      <h1 class="title"> 
          <a class="title-link" href="https:&#x2F;&#x2F;axlescalada.github.io&#x2F;">
          axlscld  
          </a>
      </h1>
      <div class="menu">
        <a href="https://axlescalada.github.io/blog/" class="menu-item">Blog</a>
        <a href="https://www.linkedin.com/in/axel-escalada-728931127/" class="menu-item">Contact</a>
      </div>
    </div>
    <div class="content">
      
<div class="flex-container-blog">
  <h1 class="title">
    Cast arrays with pointers in Zig
  </h1>
  
  <p class="subtitle">2023-08-14 ‚è≤ 5 min read</p>
   <p>While implementing a Sha256 hashing algorithm using Zig, I encountered the problem of converting a [64]u8 array to a [16]u32 array. For example:</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span> </span><span style="font-style:italic;color:#4a4a4a;">//From b to s
</span></td></tr><tr><td>2</td><td><span> </span><span style="color:#c792ea;">var</span><span> b </span><span style="color:#89ddff;">=</span><span> [</span><span style="color:#f78c6c;">4</span><span>]</span><span style="font-style:italic;color:#c792ea;">u8 </span><span style="color:#89ddff;">{</span><span style="color:#f78c6c;">0b1100001</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">0b00100000</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">0b01101101</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">0b01100101</span><span style="color:#89ddff;">};
</span></td></tr><tr><td>3</td><td><span> </span><span style="color:#c792ea;">var</span><span> s </span><span style="color:#89ddff;">=</span><span> [</span><span style="color:#f78c6c;">1</span><span>]</span><span style="font-style:italic;color:#c792ea;">u32</span><span style="color:#89ddff;">{</span><span style="color:#f78c6c;">0b1100001_00100000_01101101_01100101</span><span style="color:#89ddff;">};
</span></td></tr></tbody></table></code></pre>
<p>After trying a few things, I came up with this solution (not the most elegant, but we'll see later how Zig achieves the same result):</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">cast</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">buffer</span><span style="color:#89ddff;">:</span><span> [</span><span style="color:#f78c6c;">64</span><span>]</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">blocks</span><span style="color:#89ddff;">:</span><span> [</span><span style="color:#f78c6c;">16</span><span>]</span><span style="font-style:italic;color:#c792ea;">u32</span><span style="color:#89ddff;">) </span><span style="font-style:italic;color:#c792ea;">void </span><span style="color:#89ddff;">{
</span></td></tr><tr><td>2</td><td><span>  </span><span style="color:#c792ea;">var </span><span>idx</span><span style="color:#89ddff;">: </span><span style="font-style:italic;color:#c792ea;">usize </span><span style="color:#89ddff;">= </span><span style="color:#f78c6c;">0</span><span style="color:#89ddff;">;
</span></td></tr><tr><td>3</td><td><span>  </span><span style="color:#c792ea;">var </span><span>idxBuff</span><span style="color:#89ddff;">: </span><span style="font-style:italic;color:#c792ea;">usize </span><span style="color:#89ddff;">= </span><span style="color:#f78c6c;">0</span><span style="color:#89ddff;">;
</span></td></tr><tr><td>4</td><td><span>  </span><span style="font-style:italic;color:#c792ea;">while </span><span style="color:#89ddff;">(</span><span>idx </span><span style="color:#89ddff;">&lt; </span><span style="color:#f78c6c;">16</span><span style="color:#89ddff;">)</span><span> : </span><span style="color:#89ddff;">(</span><span>idx </span><span style="color:#89ddff;">+= </span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">) {
</span></td></tr><tr><td>5</td><td><span>    blocks[idx] </span><span style="color:#89ddff;">= </span><span style="color:#82aaff;">@as</span><span style="color:#89ddff;">(</span><span>u32</span><span style="color:#89ddff;">,</span><span> buffer[idxBuff]</span><span style="color:#89ddff;">) &lt;&lt; </span><span style="color:#f78c6c;">24 </span><span style="color:#89ddff;">| </span><span style="color:#82aaff;">@as</span><span style="color:#89ddff;">(</span><span>u24</span><span style="color:#89ddff;">,</span><span> buffer[idxBuff </span><span style="color:#89ddff;">+ </span><span style="color:#f78c6c;">1</span><span>]</span><span style="color:#89ddff;">) &lt;&lt; </span><span style="color:#f78c6c;">16
</span></td></tr><tr><td>6</td><td><span>        </span><span style="color:#89ddff;">| </span><span style="color:#82aaff;">@as</span><span style="color:#89ddff;">(</span><span>u16</span><span style="color:#89ddff;">,</span><span> buffer[idxBuff </span><span style="color:#89ddff;">+ </span><span style="color:#f78c6c;">2</span><span>]</span><span style="color:#89ddff;">) &lt;&lt; </span><span style="color:#f78c6c;">8 </span><span style="color:#89ddff;">|</span><span> buffer[idxBuff </span><span style="color:#89ddff;">+ </span><span style="color:#f78c6c;">3</span><span>]</span><span style="color:#89ddff;">;
</span></td></tr><tr><td>7</td><td><span>    idxBuff </span><span style="color:#89ddff;">+= </span><span style="color:#f78c6c;">4</span><span style="color:#89ddff;">;
</span></td></tr><tr><td>8</td><td><span>  </span><span style="color:#89ddff;">}
</span></td></tr><tr><td>9</td><td><span style="color:#89ddff;">}
</span></td></tr></tbody></table></code></pre>
<p>The first 8 bits buffer[idxBuff] are casted to 32 bits using the @as builtin function, and then shifted left (&lt;&lt;) 24 positions to fill with 0, moving the initial 8 bits from the right to the left.</p>
<pre data-linenos data-lang="yml" style="background-color:#212121;color:#eeffff;" class="language-yml "><code class="language-yml" data-lang="yml"><table><tbody><tr><td>1</td><td><span style="color:#f07178;">initial value</span><span style="color:#89ddff;">: 0</span><span style="color:#f78c6c;">1100001
</span></td></tr><tr><td>2</td><td><span style="color:#f07178;">u32 casted</span><span style="color:#89ddff;">: </span><span style="color:#c3e88d;">00000000 00000000 00000000 01100001
</span></td></tr><tr><td>3</td><td><span style="color:#f07178;">24 left shifted</span><span style="color:#89ddff;">: </span><span style="color:#c3e88d;">01100001 00000000 00000000 00000000
</span></td></tr></tbody></table></code></pre>
<p>The same is done with the next 3 values, but changing the size and the number of shift left positions. The next value buffer[idxBuff + 1] becomes:</p>
<pre data-linenos data-lang="yml" style="background-color:#212121;color:#eeffff;" class="language-yml "><code class="language-yml" data-lang="yml"><table><tbody><tr><td>1</td><td><span style="color:#f07178;">initial value</span><span style="color:#89ddff;">: 0</span><span style="color:#f78c6c;">0100000
</span></td></tr><tr><td>2</td><td><span style="color:#f07178;">u24 casted</span><span style="color:#89ddff;">: 0</span><span style="color:#f78c6c;">0000000_00000000_00100000
</span></td></tr><tr><td>3</td><td><span style="color:#f07178;">16 left shifted</span><span style="color:#89ddff;">: 0</span><span style="color:#f78c6c;">0100000_00000000_00000000
</span></td></tr></tbody></table></code></pre>
<p>After that cast and shift, a bitwise OR operation is performed with the casted values. This OR operation combines the four values as follows:</p>
<pre data-linenos data-lang="yml" style="background-color:#212121;color:#eeffff;" class="language-yml "><code class="language-yml" data-lang="yml"><table><tbody><tr><td>1</td><td><span> </span><span style="color:#c3e88d;">1100001 00000000 00000000 00000000 |
</span></td></tr><tr><td>2</td><td><span>         </span><span style="color:#c3e88d;">00100000_00000000_00000000 |
</span></td></tr><tr><td>3</td><td><span>                  </span><span style="color:#c3e88d;">01101101_00000000 |
</span></td></tr><tr><td>4</td><td><span>                           </span><span style="color:#89ddff;">0</span><span style="color:#f78c6c;">0110010
</span></td></tr><tr><td>5</td><td><span> </span><span style="color:#f07178;">Result</span><span style="color:#89ddff;">:
</span></td></tr><tr><td>6</td><td><span> </span><span style="color:#f78c6c;">1100001_00100000_01101101_01100101
</span></td></tr></tbody></table></code></pre>
<p>Finally we end up with the desired value</p>
<p>0b1100001_00100000_01101101_01100101</p>
<h2 id="how-zig-solve-this">How zig solve this?</h2>
<p>check the code here</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">round</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">d</span><span style="color:#89ddff;">: *</span><span style="font-style:italic;color:#c792ea;">Self</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">b</span><span style="color:#89ddff;">: *</span><span style="color:#c792ea;">const</span><span> [</span><span style="color:#f78c6c;">64</span><span>]</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">) </span><span style="font-style:italic;color:#c792ea;">void </span><span style="color:#89ddff;">{
</span></td></tr><tr><td>2</td><td><span>  </span><span style="color:#c792ea;">var </span><span>s</span><span style="color:#89ddff;">:</span><span> [</span><span style="color:#f78c6c;">64</span><span>]u32 </span><span style="color:#c792ea;">align</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">16</span><span style="color:#89ddff;">) = </span><span style="color:#f78c6c;">undefined</span><span style="color:#89ddff;">;
</span></td></tr><tr><td>3</td><td><span>  </span><span style="font-style:italic;color:#c792ea;">for </span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">@as</span><span style="color:#89ddff;">(*</span><span style="color:#c792ea;">align</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">) </span><span style="color:#c792ea;">const</span><span> [</span><span style="color:#f78c6c;">16</span><span>]u32</span><span style="color:#89ddff;">, </span><span style="color:#82aaff;">@ptrCast</span><span style="color:#89ddff;">(</span><span>b</span><span style="color:#89ddff;">)),</span><span> 0</span><span style="color:#89ddff;">..) |*</span><span>elem</span><span style="color:#89ddff;">,</span><span> i</span><span style="color:#89ddff;">| {
</span></td></tr><tr><td>4</td><td><span>    s[i] </span><span style="color:#89ddff;">=</span><span> mem.</span><span style="color:#82aaff;">readIntBig</span><span style="color:#89ddff;">(</span><span>u32</span><span style="color:#89ddff;">,</span><span> mem.</span><span style="color:#82aaff;">asBytes</span><span style="color:#89ddff;">(</span><span>elem</span><span style="color:#89ddff;">));
</span></td></tr><tr><td>5</td><td><span>  </span><span style="color:#89ddff;">}
</span></td></tr><tr><td>6</td><td><span style="color:#89ddff;">...
</span></td></tr><tr><td>7</td><td><span style="color:#89ddff;">...
</span></td></tr><tr><td>8</td><td><span style="color:#89ddff;">}
</span></td></tr></tbody></table></code></pre>
<p>Let‚Äôs break down each line and explain what it does:</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span style="color:#c792ea;">var </span><span>s</span><span style="color:#89ddff;">:</span><span> [</span><span style="color:#f78c6c;">64</span><span>]u32 </span><span style="color:#c792ea;">align</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">16</span><span style="color:#89ddff;">) = </span><span style="color:#f78c6c;">undefined</span><span style="color:#89ddff;">;
</span></td></tr></tbody></table></code></pre>
<p>The first line declares an array of unsigned 32 bits with a 16 byte alignment. This ensures that the memory address used to store s is divisible by 16. Then the array is declared as undefined</p>
<p>Second line:</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#c792ea;">for </span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">@as</span><span style="color:#89ddff;">(*</span><span style="color:#c792ea;">align</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">) </span><span style="color:#c792ea;">const</span><span> [</span><span style="color:#f78c6c;">16</span><span>]u32</span><span style="color:#89ddff;">, </span><span style="color:#82aaff;">@ptrCast</span><span style="color:#89ddff;">(</span><span>b</span><span style="color:#89ddff;">)),</span><span> 0</span><span style="color:#89ddff;">..) |*</span><span>elem</span><span style="color:#89ddff;">,</span><span> i</span><span style="color:#89ddff;">|
</span></td></tr></tbody></table></code></pre>
<p>The second line takes b (a pointer) and casts it using @ptrCast converting b to a pointer of *align(1) const [16]u32 to achieve this is needed to use the builtin function @as to coerce the type. In this case the pointer is aligned to 1 because b is aligned to 1.</p>
<p>The same result can be achieved by doing this:</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span style="color:#c792ea;">var </span><span>bp</span><span style="color:#89ddff;">: *</span><span style="color:#c792ea;">align</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">) </span><span style="color:#c792ea;">const</span><span> [</span><span style="color:#f78c6c;">16</span><span>]</span><span style="font-style:italic;color:#c792ea;">u32 </span><span style="color:#89ddff;">= </span><span style="color:#82aaff;">@ptrCast</span><span style="color:#89ddff;">(</span><span>b</span><span style="color:#89ddff;">);
</span></td></tr></tbody></table></code></pre>
<p>In this example the use of @as is not necessary because the type is declared along with the variable.</p>
<p>After casting b the result is iterated with a for loop that receives the casted pointer and an index.</p>
<p>Third line:</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span>s[i] </span><span style="color:#89ddff;">=</span><span> mem.</span><span style="color:#82aaff;">readIntBig</span><span style="color:#89ddff;">(</span><span>u32</span><span style="color:#89ddff;">,</span><span> mem.</span><span style="color:#82aaff;">asBytes</span><span style="color:#89ddff;">(</span><span>elem</span><span style="color:#89ddff;">));
</span></td></tr></tbody></table></code></pre>
<p>At this point we already have a u32 value that can be stored in s array. So.. why we don‚Äôt store it just as it is?</p>
<p>Well it‚Äôs not that easy because the endianness comes into play. For example, consider this u8 array:</p>
<pre data-linenos data-lang="bash" style="background-color:#212121;color:#eeffff;" class="language-bash "><code class="language-bash" data-lang="bash"><table><tbody><tr><td>1</td><td><span style="color:#82aaff;">{0b1100001, 0b00100000, 0b01101101, 0b01100101</span><span>}
</span></td></tr></tbody></table></code></pre>
<p>is stored in memory like this:</p>

  <!--  -->
  



<figure>
    <img src="https:&#x2F;&#x2F;axlescalada.github.io&#x2F;processed_images&#x2F;first-zig-post.ea140df3758ae9df.jpg" />
    
</figure>
<p>and if you have an architecture that uses little endian when you cast the u8 array to a u32 array the value will be read reversed, like this:</p>

  <!--  -->
  



<figure>
    <img src="https:&#x2F;&#x2F;axlescalada.github.io&#x2F;processed_images&#x2F;second-zig-post.8682255852f94cc4.png" />
    
</figure>
<p>This is because when you cast the u8 pointer to u32 pointer the addresses remain in the same location, thus when the u32 value is read asumes that it was stored using little endian. But we want to keep the same order in this case.</p>
<p>So this third line achieve that:</p>
<pre data-linenos data-lang="zig" style="background-color:#212121;color:#eeffff;" class="language-zig "><code class="language-zig" data-lang="zig"><table><tbody><tr><td>1</td><td><span>s[i] </span><span style="color:#89ddff;">=</span><span> mem.</span><span style="color:#82aaff;">readIntBig</span><span style="color:#89ddff;">(</span><span>u32</span><span style="color:#89ddff;">,</span><span> mem.</span><span style="color:#82aaff;">asBytes</span><span style="color:#89ddff;">(</span><span>elem</span><span style="color:#89ddff;">));
</span></td></tr></tbody></table></code></pre>
<p>First of all, the u32 value <strong><em>elem</em></strong> is passed to the <code>asBytes</code> function from the standard library to retrieve a slice of the underlying bytes of 'elem'. As a result, we end up with the same u8 values in the same order before being casted. Then, this slice is passed to the 'readIntBig' function. This function reads the slice of u8 values using big endian and casts it to u32.</p>

  <!--  -->
  



<figure>
    <img src="https:&#x2F;&#x2F;axlescalada.github.io&#x2F;processed_images&#x2F;third-zig-post.ce5889458f03db23.png" />
    
</figure>
<p>The result is stored in s array, and that's how Zig achieves this casting.</p>

</div>

    </div>
    <div class="footer">
      <hr>
      <p>Author: Axel Escalada</p>
      <p>All opinions expressed on this blog are my own and do not necessarily reflect the views, opinions, or policies of any current or past employers, organizations, or institutions I may be associated with. Any opinions, information, or content provided on this blog are intended for informational and entertainment purposes only.</p>
    </div>
  </div>
</body>

</html>
